SPEAKER 0
okay, just before I make a start, just a couple of things, um so this week we're going to start with Lab five, that's going to be posted and so in the session this week you can ask questions um well I mean you can ask questions about Lab four still as well but I noticed um there's still a lot of people haven't submitted anything for love for and that's fine because it's you still got two weeks but um try and make use of this week to to inquire or ask or get clear um the requirements for Lab Five as well. Now Lab five is going to be dealing with audio and a lot of what I'm going to introduce you today is the kind of foundation where he's going to start with the, with the lab. Um so uh the other thing is that um we're still working through, we're still, you know, clearing up all the lab marks at the moment there seemed to be an issue that some of the students thought that they had with them with processing on the lab machines. It's actually not, I don't think that that's an issue. If you if you've written any code that doesn't seem to be capturing your key presses. Um It's generally the issue is generally that you have to click on, well you have to have a draw loop in there, you have to have your application open and your application window needs to be in focus or selected before you start typing key presses or doing mouse clicks or whatever if you click in the console of the application. So for example um if you're in an application and you click on the console here and you start pressing keys and hoping that your application will capture your key presses. That's not going to happen. It has to be in the actual application window that opens that has to be selected so that when you press keys those keys are directed to your programs. Otherwise if you click on this editing window your key presses will start changing the code. Or if you clicked on another window the key presses will go somewhere else. So just keep that in mind um That you know it may not be an error that you're experiencing just that you haven't selected the right application window. Are there any questions about love for before we get going? Not not we're not gonna get in detail about um how to answer it. But there was a typo as well. So I've posted a few announcements. Make sure you look at those. I've tried to do those in both. Discord and um a class so that um hopefully don't miss those announcements. Um go back and check the announcements on a class from time to time just to make sure that you're not missing anything. The other announcement that I wanted to make is that those of you who missed the midterm written exam or the lab test one? Um Due to medical reason Um I will be running a makeup test in L. A. S. 1000 and to be on Wednesday. So please come to that lab, not just your normal lab. Just come to listen building 1000 and two B. Which is the small lab on the stadium side of the lesson building. That's the building that we have the lectures in on Wednesdays. So if you're in that position please send me an email to confirm because I want to make sure that we've got enough space. I've been emailing those who have contacted me but I suspect that it's possible that some of you got through the cracks because you've either emailed me without the course code or something like that has happened. So please if you're in that situation um you will need to do this love test. If you don't if you're not here then you will be getting, you won't be getting marks for these assessments. So. Alright. Um Okay that aside let's get into other lectures. Sorry when is lab forward you again? So all of the due dates are written on the lab documents. Okay so Lab four is not due this week, it's due next week. You get two weeks for each of these remaining three labs. Lab 45 and six. Um The due dates are shown on the calendar in the class but they're also written explicitly the time and the date on the lab document. Um Right so you will have more time to do lab for but the session itself, the lab session is dedicated to um you know, looking at Lab five. So, you know, ask use those times to ask questions. You can ask questions about any of the labs at any time from any of the th that's fine. But use this session for lab five anyway, let's get into the lecture. So today we're going to gradually be be exposed for the rest of the course to new kinds of reference types and objects that we can use for different purposes. So we're going to get a lot more practical um in the sense that now we know how to write programs with some basic logic and some basic control flow, we know how to use variables. There will be things from time to time that we will encounter um that that we have to watch out for and and things that are general to programming but we're gonna start using objects a lot more um and they're gonna make life a lot easier. So there are a bunch of different useful types um and just by way of like where to find things, we will be talking about array lists um uh with the different versions of array lists um which are kind of a more advanced version of an array. And you might be thinking well if I've done some programming before, why can't I just use this in Lab four? Well the goal of lab for is to use normal arrays and so you have to answer those questions with normal arrays. But what you're going to appreciate when we, when we learn about these is how much easier they are to use than arrays and how much extra functionality you can get out of them. We're going to be looking at reading from a file as well. I'll probably look at this um in Wednesday's lecture but that's sort of related to part of Lab five as well. And then next week when we start to talk about images, we're going to use a type called P image and all of these types by the way like P vector, which we've looked at in the last lecture, these are all types that are built into processing, so we don't need to explicitly import them into our program. Um and so they're relatively straightforward. We just have to declare these types out of the box and we can look at the reference manual and see, oh there's a type. So for example, if you want to you can actually use a type to capture all of the points that you want to build for a polygon shape. And there's a whole set of methods that can help you capture and link together points to create a shape. Now, previously we didn't do that, we just we just painted a shape directly to the screen. Using these methods like Lionel lips and so on. But there is an object to that can do that. Um So we'll look at these gradually over the remainder of the course, we're going to deviate from that a little bit today, just for something different because we've spent a lot of time looking at graphics and and you know, drawing geometry to the screen. Um so just to break that up a little bit, we're gonna start looking at audio. Okay, now the audio objects that we're going to use, they are not built into processing. Okay. So they're they're actually imported their external to processing but um you can easily through the processing interface you can easily um set this up or configure it so that you can access these libraries and you know, when you're working on your own projects and and you're working with things that are outside of what processing delivers. But you found some code or you found some other libraries that you might want to use. The mechanism that you go through to set up your programs so that you can access that stuff and then use these other types and things in your programs is very much the same as what you're doing here today. Okay, so, um right, so let's let's just recap and this was a slide that I had earlier in, I think a couple of weeks ago when I was talking about a week ago when I was talking about a raise and two D arrays. And I was talking about this concept of audio being essentially one or more sets of one dimensional arrays and then images being two dimensional race typically restoring pixel values or in the case of sound we actually store voltage levels or current levels. And I just wanted to talk about that a little bit more in the context of audio, like what is what is what are we actually recording and using when we're dealing with sound? So sound is actually the perception of molecules in the air vibrating. There actually pressure waves. We're speaking, we're actually generating changes in the pressure and they are transmitted through the air and our eardrums actually respond to that by oscillating. And they oscillate and send a signal to the brain and that's how we hear stuff, right? So it's much like a you know a drum uh you know a drum when we beat it, it's it's vibrating, it's oscillating and and makes a sound. So this oscillation is inherently um connected to the idea of asana side. So we're going to start today just looking at audio related to individual sinus sides. Um And you know, individual sinus sides basically have they generate. Well they're considered what we call a tone. Um They have a single frequency and depending on how um fast we play back a sine wave and how fast we make a surface of the speaker for example vibrate, we're going to hear a particular pitch to that tone. Now if we vibrate faster um that corresponds to a faster changing sign aside and we hear a high pitched note. If we vibrate more slowly, the lower pitched note more Basie more Trevor lee is a high pitch. More Basie is the low pitch, low pitch. So if does anyone just show of hands, anyone play an instrument? Anyone play piano or or any kind of instrument right into music musical instruments? Right. So on the piano if you look at your, when you're learning piano you always um you start with this concept of middle C. Which is a position on the piano and that particular note has a certain frequency associated with it. Um And um the a. That that is just above that note is usually called a concert A. And that as a as a particular frequency Um is really on your side wave that oscillates at 440 times in one second. And what do we mean by oscillate? We mean that the wave itself goes through one cycle. So we've seen the senior side goes through one cycle in two pi radiance. This is exactly the same as traversing a circle one time. Right? And at each point on that circle just taking the amplitude of the y direction um of on that circle. Um And as you do that as you go around a circle, if you go around one time you're gonna trace out this this sign your side wave. Right? So that's we consider that one cycle to go all the way around and then obviously you start repeating. Right? So so this is actually this describes exactly what's happening with the pressure. The pressure is sort of vibrating in this sound wave, the molecules in the air of vibrating and that's sort of transmitted to the ear. And then the the air vibrates as well. So sound is really the response to changes in air pressure. Okay, now the eardrum vibrates and sends that signal. Now, how do we do it with digital technology where we have some kind of voltage or some kind of current that is also oscillating at at a particular rate and we use that current to drive a magnet on a speaker to make the skin of the speaker kind of vibrate at that same kind of rate. Okay, so the electricity ultimately drives the speaker and then in code we actually use numerical values to represent the voltage levels that we send to a to a sound card that drives the speaker and so on. But as far as our programming is concerned, we just need to think about this as a bunch of numbers um that describe a wave form and we've seen the sign inside wave forms before. So just a couple of features of a sign inside, so the distance from a peak to a peak, or the distance from a trough to trough, basically the distance that traveled before the waveform starts repeating itself is known as the period. Okay this is the number of seconds it takes to do one cycle around that circle or one cycle through that sine wave. Um And then we think of, so that's a time but we also think of a frequency associated with that and what's the frequency? It's just one over that amount of time. And that's basically cycles per second. So how many if it takes so many seconds to do one cycle or how many cycles would you actually go through in one second? Right that's frequency. So cycles per second is effectively known as hurts. So if you hear you've probably seen speakers before and you've seen you know speakers that have like low hertz and high hertz and very basic speakers have very low hurts. Their very low frequency and very tweeters. And think very small speakers that that generate really high pitched sounds have a very high hurts associated with them. They're just able to vibrate at different in different ranges. Okay so so if I if I took the period um for 20 hertz 20 hertz as a frequency would be so if I rearrange this formula period would equal one over frequency or frequency equals one over period. You just swap these two around Um the period of 20 Hz would be 1/20 cycles per second which is about .05 seconds it takes for one cycle. Right? So 0.05 seconds will give you a low frequency um If you only take five times 10 to the minus five seconds which is very very fast to travel one cycle then then you're looking at a frequency of about 20,000 or 20 kilohertz, right? Which is very high frequency. I picked those numbers on purpose because that's basically the range of audio that we can hear in right. Generally sounds that are below 20 hertz, we can't really hear them very well and sounds that are above 20 kilohertz, we can't really hear them very well either. Dogs can hear them. Dogs can hear higher pitched sounds, but humans generally now everyone's slightly different but most of us fall within this range. This is kind of like visible light. Like we don't see UV light, we don't see infrared light but we see the visible spectrum with the audio is the same kind of idea. Our ears are only working really over a certain range now when we speak um we can only generate voice kind of sounds in a much smaller range. So from 0 to 4 kilohertz music on the other hand, usually encompasses a very wide range of different frequencies and they're all mixed together. In fact like sound in general is really just a mixture of all of these different sinus sides happening at the same time. And when you add them all together you might get some weird looking um Waveform that that basically describes the sound that is happening at any given time. Um but they can also be decomposed into into separate sinusitis that add together to give that that sound. So music is typically in the range of 20 kHz. The piano is sort of um You know close to speech. It's sort of between this range of 27.5-4,000. So we can hear much wider range than what we can play on the piano for instance. Um So there are a couple of features of the sound waves. One is the amplitude, which is if I look back is the distance from the trough to the trough. So how big is it in the vertical direction and that's associated with volume. Uh and then how squashed is it is associated with pitch? Right? So if it's moving faster, that means in a small amount of time it's going to go through more cycles. It's going to feel squashed and that's higher pitch. And if it's moving more slowly it's gonna feel spread out and that's lower pitch. So the frequency is associated with pitch or the period is associated with pitch. Same thing. The amplitude is associated with volume. All right. So ultimately though the senior side waves, we store them as a bunch of unique samples. So a bunch of new a bunch of numbers, right? So the number of samples that we have um basically describes how how high the resolution is or how how smooth is this curve that we can generate from these numbers later. We typically work within so floats um in processing most of the time we're working with floats but in java applications you may be working with doubles as well for this sort of thing. Okay. Alright. So I said that the sine wave is basically generated by a point moving around this circle. Okay. As we move around the circle, if I stop here for instance, I've got a Y. Value and an X. Value. Right? And the the amplitude of my value is really what we're looking at here. Okay. The amplitude of the X value also looks like this but it's slightly shifted so it also oscillates between one and negative one. But if you think about it like this is one here and this is negative one here. And so the X value is going to oscillate like this and the y value is going to oscillate like this. Right? But if you trace that out over time, it's gonna look like this. Alright, um we know that takes two pi to go through one cycle. That's the same as 360Â° to go all the way around this this circle. Okay, so how do we build a sine wave? Um Well we can use this formula. So the formula that relates frequency and the position in time along the time axis because usually these audio signals, they evolve over time. right at any one instance in time, there's just a single value. Um And so we can we can use a formula to generate that and um depending on the value of f F will give us the frequency which will control how fast this is changing and t will just give us an idea of where along that wave we are. And but of course, you know, time time is relative. And when we've got a raise their just arrays of numbers, we don't really have any association with time. It's just a collection of numbers. Right? So how do we make that connection? Well, we need to understand how many samples or how fast we want to play this thing back at and how many samples we want to play back in a specific amount of time. And we use a thing called a sampling rate, which basically defines the number of samples in one second. And so if we look at one cycle, right? And we assume that we can play back, say 1000 samples in that one cycle, we could generate um uh 1000 samples over that cycle and we could do that by breaking up that time into a variable i which is our loop counter divided by um some resolution parameter, which is our sampling right here. And essentially what we can do is we can vary i over that range. Um so that, you know, by the time it reaches a value of one for instance, um we've moved a certain proportion along this way form, we've moved through one cycle for instance. Okay so let's have a look at um What happens if we only generate a sample? Like we did we we only generate a few samples while we do that. Um So if we have fewer samples when we're doing that and we're moving at a certain speed, um we have to make sure that we have enough samples that we can rebuild the wave form. Right? If I only had like two or three samples, I might not be able to build the shape of this thing. So I have to make sure that I've got enough samples in there. And typically the rule of thumb is that we want typically audio, we want enough samples to have at least twice as many samples as the frequency of whatever that sound is that we're trying to capture or reproduce. So if most audio is up to 20 kilohertz then we need to have a sampling rate that's probably twice that. So this is why cd quality audio, you see sampling rates around about 44 kilohertz. We have much higher than that. And that's what we're saying, is that sort of like a minimum that we should have. We can have higher than that. Um but not small, not less than that because then we were not able to reproduce all of the different frequencies that are in there in the sound, we can't reproduce them, we can't hear them. Okay so um So for most audio we'll use this and you'll find that this is sort of a default um sampling rate that when we generate audio a raise and then we play them back. They mostly play back at this rate. So there's an expectation that I'm going to have about 44,000 samples per second um In my array. So when I play it back it plays back through 44,000 of these samples in one second. Um All right. Yeah. Um Quick Question. If I if I have a fixed rate 44,000 And I had 44,000 samples. My array would take one second to play back, right? 44,000 samples per second. If if I have that number of samples in my array and I played back at the same rate, what would it appear to take to get through? Like how quickly would we get through? Um All of those samples, I had half as many samples and I'm playing at the same rate before I had 44,000 samples. And it took one second. Now I have 22,000 and I'm playing the same rate. So many samples per second. It takes half the amount of time. Right? Right. Earth to e. c. s. 1710. If I had half the amount of samples it would take half the amount of time to play them back at the same speed. Right? Um Okay so um but those samples if they're spread out over the wave form it would appear that that wave form played back twice as fast. So it would sound different. And actually what do you think it would sound? Lower pistol, Higher pitched if it seems like it's moving quicker? Have a guess. Higher pitch, high pitch. Yeah. So it's going to appear to go through the whole wave form but in a short much shorter time if we played back in that way. So say I had a wave form that goes through one cycle and I played back. I only took every second sample so I'm still got the shape right? But I only took every second sample. I played it back at the same rate. It would appear to go through one full cycle in half the time. Which would be like a squashed version of that sine wave. It would sound higher pitch. I'll show you some examples of this in a second. All right, so the other thing that we're thinking of with these sampling rates is that, you know, there's a there's a cost involved in storing audio as there is in storing images and the cost involved is that um imagine I have one of these arrays that's just the left channel and then I have another one of them for the right channel. So I've got stereo and it's un compressed If I have 44,000 samples per second. Oops and I have two channels and I have one minute of audio so I have 60 seconds. So I'd have 60 seconds in one minute times 44,000 samples numbers In that one second. So 60 seconds times that I'd have 60 times 44,000 samples. Right? Which is And then I have two channels. That's about um 5.3 million samples in one minute. Um now each of those samples depends on what we're storing it as if we're storing it as a float. Then I have 32 bits per sample. Four bites. So four bytes times that that would take up 21,168,000 bytes In memory for one minute of audio. Which is about 21 MB. That's a lot. Right. Now you say we've got gigabytes and gigabytes. Well you know that's a lot it's it's un compressed. These especially audio and visual signals when we represent them this way they generally take up a lot of information. And so um this is un compressed though but if we have um we have ways of compressing and what are those? How come those files are so much smaller. So things like MP three files or compressed audio files are much smaller how they smaller. Well they're smaller because we've learned how we can remove sounds from that that we can't hear. Anyway. And so because we don't perceive them, we throw them away in the same way that a jpeg image, jpeg image compared to a pure image um like a tip or something like our bit math is much more compressed because there are visual things that we can throw away that we don't see. And that's how we get compression, compression ultimately is very important when we're talking about audio signals, we're not going to do compression in this course, so don't worry about it yet. But just to give you an idea, like, you know, even to store just a little bit of audio takes up a lot of space. All right, So how do we synthesize sound and processing? So the first thing we need to do, we're going to actually use an audio sample object and this audio sample object actually comes from a library that's not built into processing. So the first thing we have to do in order to access. So I'm just gonna go in here and like when you're in a processing sketch, um what you'll see, I've actually got the library in here. Um drag the window down. Um There's a library in here called sound. I'm going to I'm sorry, I'm going to pretend that we're starting without it. So I'm gonna remove it. Okay, now, when that's removed, which it is initially when you try to use an object like this, you're going to get an error saying that this doesn't exist. Right? This this type does not exist, um or this class, audio sample does not exist. And so how do we deal with that? Okay, So if it's built into the processing, it will exist, right? It knows where to find all of the processing stuff. If it's not, we've got to go into um our import library and if it's not listed here, it means it's not installed. So we manage libraries and we look for sound and there's a sound library that this is actually coming from. We install it. Okay. And now when it's installed and processing knows about it now, we'll see it listed. So the sound library is listed here. Okay, So this is the same process for any library that is external to processing that we want to build into our program, we need to make sure processing knows about it and it's installed, and then you can you can go up here and I'm just going to get rid of that for a second, and you can say, okay, I want to use that. So, again, my program doesn't know about it because I haven't imported it. And remember we talked about this import statement at the beginning of the course. So if I go down and click on sound, this library, I want to import, it's going to automatically add that import for me if I know where it's stored? Like what package and everything that thing is stored. I can just type this import indirectly. Now that I've got that, it's basically saying that all of the classes that are associated with that sound library have been imported and are available for me to use in my program. Um now I don't have to use all of them. This wild card is just specifying all of the clubs. I could look for a very specific class, um like the class that we're using here, but you know, it's easier just to import the whole thing and then you can use all different classes at any given time. Alright, So that's that's the first thing that we need to do to make this thing available to us, and now we can declare variables of that type and use them. So how do we actually go about creating a sound? So what we need to do is we first need to construct this object. Okay. And we look at how it can be constructed. So we look at all the various constructors that are available, and it turns out that there are two in particular. There's lots of different ways that we can generate a sample. But this particular object is really used for synthesizing our own audio. And what we're going to do first to synthesize a sine wave and we're going to use that as a piece of audio. So what we need to do is um this particular sound sample needs to have a reference to the program itself. Um and so we're going to talk about what that means a little bit later, but when we use the constructor um to create this audio object, there's a special reference to the program itself, which we're going to call this at this point in time. We're going to learn more about what this means in the next course. So every time you use this, um you're going to just use this keyword this. So don't worry about what that means exactly here yet. And then you've also got to pass it some kind of data array. So there's um I can pass it if I look at here, there's a there's a property here or a field or an argument. Sorry, that is called data. And then when I go and look at what data is, it says it's an array of float values to be used as the audio samples sound. So we can generate any sets of values that we want. Right? And we can try and play it back. We can generate nonsense if we want to try and play random values. Heads up in the next lecture on Wednesday, I'm going to generate some different kinds of wave forms. One of them is going to be white noise. So random values is one thing we can play back. It just sounds like, you know, hissing kind of snow that you get on. Used to get on old TVs now now they're digital. So they don't just crash. But anyway, So we can generate different things. Um and we can if we use this version of the constructor, it just uses the default frame rate, which is set to 44,100 which is the typical, you know, rate at which audio would be played back. Or we can use a version of the constructor that will set the frame rate. So we can set our own frame rate and its frame rate, something we can change. So that once we've got at array there that we want to play back as audio, we can choose how fast to play it back by changing the frame rate. Okay? So, um so this is how we sort of go about generating the sample. We take that formula. Right? And we want to build the array first. So, let's go over to the code here and have a look at what we're doing. All right, so s are in that formula was the sample. Right? So we're gonna set that to the 44,100 and say we wanted to generate that concert a note which is 4 40 hertz. So we're gonna pick a fixed value for our frequency, right? We could also vary this and have different frequencies, but let's just start with a fixed one. We're going to create a sine wave, which is a float array. Okay? And we're gonna just create one cycle, we're just gonna create 44,000 samples. Right? So we don't have to do that. We could we could generate much bigger than that. So we'd have lots of cycles going on, right? Um This number could actually be arbitrary. How many samples we want to play back? It's just gonna decide how big is our array. And that ultimately combined with the rate that we play it back, is going to tell us how long it takes to play this particular array back. Alright, so we generate that. Okay, so that's an array And then we're gonna use a loop to sample between zero the first element and up to the maximum a number of elements, which in this case is the size of our array, right? I could also change this to design wave length. Oops, did the same thing. Okay, now I'm going to go through all of those elements and I'm going to use this formula Right? Which the two pi F T. But I'm replacing the T with this eye on S. R. Okay, And this is going to basically allow me and I'm using the built in constant for to pay here, it's going to generate away form that according to that frequency will go through enough cycles in that sample rate period. Okay, now, if I change the frequency, I'm going to actually go through more of a cycle in that same sample rate period. Um So that's going to generate the sign components and we're gonna sign those to our sine wave array. Now that I've got the array, I can set up this audio sample and this object basically loads in that array, just like a string would load in an array of characters. But it allows us now to get some functionality on how to play this array and what this audio sample object will allow us to do. There's a lot of different methods associated with it. We can query this piece of audio to see how many channels of audio it has. We can see how long it's going to take to play it back. Given the frame rate, we can jump to a location in the audio sample and play we can play it all the way back, we can loop it um which will send that data to the sound card so that we can hear the sound generated. Now, I'm not sure if you're gonna be able to hear this, but you can also set the amplitude. So once we've got that object it's it's referred to by this reference sample. Right? We created this um sample reference here, it's a reference to this kind of object. We've instance, she hated it here by using the data that we generated, linking it to that object and then we can do things with it by calling its methods. So I've got some methods here where I'm just querying the object that we created and then we set the amplitude. I'm going to set it to half the amplitude. Um Usually an amplitude varies between 01, like an amplitude of one so minus one and one down to zero and we can control that and then I can play it. So I'm just gonna play it now and I hope that you can hear this. Can you hear that? Did everyone hear that? It was just a small noise. Hear that? Okay let's loop it instead because it's only playing for a short duration. Can you hear that, yep? Okay so let's change the frequency Up to 880. Let's change the frequency down. Okay so here you can see by changing the frequency right? Making this basically travel further through the the typical sinus. Oid faster. Right? By upping the frequency you're going to generate a sine wave that changes like in the same number of samples. It's going to go through many many cycles when you play that back at the same rate. Those vibrations are gonna happen faster on the speaker in your computer and that's going to generate the higher pitch sound? If you do a lower frequency um You know you're gonna get a I don't know if we're going to hear this. Can anyone hear anything? I can't, So let's try 40 hertz Just here 40 Hz but below 20 we stop we stop hearing it. So you can play around with this and you can generate sort of different sine waves here and run them all right. Um But the the convenience here is that we've got an object that's set up unusable and can link to the speakers in the computer and a lot of the function of how to drive the speakers and all that stuff is hidden from you. Um And someone else wrote code to do that. But we can take advantage of the fact that they've built a class here that does this stuff for you and we just have to load it up the right way and construct it the right way. And then we can call methods on this subject to get it to do things that we want. Alright. Um Okay so there's another object so that's um that's how we generate a simple tone, I'll talk I'll come back to tones. You're gonna be exploring tones and and generating different tones to go with different notes. And then you're going to be reading files in lab five that will tell you which tones to generate. So they'll basically act as a midi like a piece of music. Um And the file will just list information about the tones to play back and how long to play them back. And then when you play it it's going to play like a little melody stuff like that. Now you could also generate tones and have them like once I've got that tone generated here, I could potentially go and have a key, press for instance that um that played that tone. So if I use this this way of playing it, I could set up a key, press that when I press that key, it will play the tone. Now the tone will keep playing until it finishes right. I also have other methods where I can pause and stop or I can control I can control potentially how far how many samples of that tone I play back so that I keep the duration fixed to a certain length of time and so on. So I can play short versions of the long versions of that sort of thing. Alright, so this so there's another object. So what if I want to play some audio that I have stored like a piece of music or audio that I've recorded from the microphone, I can use the sound file object. Okay, so this is a little bit different from audio. Audio sample is really set up so that we can generate our own wave forms that we want to play back through. Sound. Sound file is generated so we can load wave forms from a file and what they support is things like un compressed audio, like wave files, A I. F files and mp three S which are compressed, it supports that as well. Okay. Doesn't support everything but it supports a number of different formats. Now, I'm just going to use an example here with wave file and when we create these objects, we actually link them to a file lane. So this is the next thing that I wanted to talk about in um in processing. So how do we actually link to a file? And so here we're gonna create a reference to an object sound file. Again, if I haven't imported processing uh all of the processing sound um types into my application, um then, you know, I'm not gonna be able to use that time in here if I just if I just imported um audio sample type that we used in the previous thing. Okay, again, I wouldn't have access to this type that I'm trying to use. So, you know, I don't need to import everything. I could just import the things that I need. Often you'll see code that does this separately. Like they will have separate import statements, just importing classes that it needs. The reason that happens is because you may not want to store everything in memory that you're not going to use. Okay, so ultimately this will be stored in your program when it runs. If you're not using it, it's probably not necessary. Okay, but for now we'll just keep keep using everything. I'm actually not using audio sample in this particular example anyway. Um Okay, so, so basically we need to a sound file basically is a reference to that links the audio buffer to a file that's going to read that file from the audio sample links to the audio buffer, that's that's basically an array that gets played to the speaker. Um And and so we generate these things slightly differently. Okay. We use this this keyword again. Don't worry about that as standard, we're just going to use that for most of these particular classes and then we link to a file. Now the file has to exist inside of our sketch folder. So the folder that this sketch is defined in the pd file is defined in, you have to put any of the resources that your program wants to access. If they're separate files, you have to be in that folder as well. So in this case the fantasy um wave folder has to be there. So let me see if I've got a I think I'm a member. Let me see, I've got a terminal here where I'm I'm in the sound files folder. Okay. So I've got a bunch of um sound waves, wave files here right there in the same folder as the sketch. Okay. And they have to be otherwise processing won't be able to find it now. That's nice because you know, you can if you want someone else to use your program, you just give them the whole folder with all of the resources in it and you should be able to run that from anywhere where you have access to processing. All right, so this is a piece of music. Um It has it's a stereo piece of music and then I've got another one that's a speech. It's just someone rattling off some american. Uh Well, you'll see. Um Alright, so and and all we're doing is we create this file. And then what I'm gonna do is to play it. I'm going to use a mouse click. So I'm just going to scroll down here and and I'm just gonna use a mouse click. Um So basically I've got in my mouse press method um I'm going to check if it's playing now this file until we press play. Until we call the play method is going to be not playing, right? And there's a method where you can create a see if it's playing or not, it's called is playing. Um So if it's playing, I'm going to do something else. I'm just gonna I'm gonna, when I click the button, I'm going to pause it and if it's not playing which is down here at the bottom of my else I'm gonna play it right? And just output a message saying that it's playing. So let's press play here. Now I've got an application window. The other thing that I'm doing in this file which I don't show on the slide, but it's in the code that's being uploaded. Is that when it's playing? Well, how do you know what's playing? You don't know it's playing. There's another method in the sound file called? Percent. Which tells you how much of it has played so far. And I use that to generate like a little progress bar. So we can see how far into the file we're going. And that's what you're gonna see on the window here. All right, So when I press play, when I click on it, it's not playing, it's gonna start playing. Okay. Fantastic. What does that mean? It means that now we can have a sound effect and remember our example where we were shooting balls at the target earlier in the course, when they hit, when we detect a hit, we can actually load up and play a sound effect when we hit something. So we can add sound files to our programs. I'm just pausing and I'm pausing and I'm showing this progress. So where does that progress come from? Um So there's uh there's a couple of methods in here. So there's pause methods is playing. There's a play method, that's the basic use of it. And then I use a couple of other methods that are in their percent. And you can see these in the reference. Now these things won't be in the processing reference, you'll have to go to um There's a at the top of the processing or site where you can select reference, you can also select libraries and if you go to libraries, you can find the sound library and then all of the reference. The manuals and things for these objects will be located there. So to draw that that progress bar. It's a little bit like that earlier lab that we did where we drew the colors. Um we visualized the combination of colors. So all we're doing here is using 5% which gives us a value between zero and 100% divide by 100. Um And then I'm just multiplying that by the size of this object and I'm drawing two rectangles, one that's fixed and then one that is filled and it just it's sizes depending on how on this percent value. Okay so I can go back and I'm almost done for this lecture. I'll talk about the the last couple of slides in the next one. But um yeah so if I wanted a different file in here I can switch this around. We'll look at some objects where you can actually open up a menu like like a file browser and select object select files. That way we can we'll also look at some objects where it can open little dialogues and we can enter values into our program as well. We'll do that soon. So now I play this one. We the people of the United States in order to form a more perfect union establish justice, ensure domestic tranquility. I'm just pausing that so we can play back. So there's two types of sort of audio we looked at today. One is generating a simple tone. A note such as a note on your keyboard and the other one is playing back a sound file when we come back on Wednesday. We'll talk about how if I have a reference note that I know the frequency of. How do I figure out the frequencies of the other notes on the keyboard? Given that they all vary from one another in a regular way. So how do if I jump up one octave? How do I actually figure out what the frequency would be if I jump down one key on a keyboard on a piano? Um It's a semi tone. Like how much does that change the frequency? Now, when we understand that, then we can easily generate sounds and we can actually create keys and make a little keyboard if we like. All right, I'm gonna stop it there and stop recording. Is there is there any of that stuff? Okay. We'll return to live lectures on Wednesday and we may have some lectures from time to time. But but for now we're going back to live lectures and then we'll see how we organize whether we have a regular virtual one or not. I know that it's easier to see the screen this way. Um But yeah, you have one. There's one question Hassan.

SPEAKER 1
Uh yeah, I just have a question regarding like the lap five. So you mentioned earlier, if we know the hurts of one note on the keyboard, we can figure out how the rest of the keyboard is gonna play. So can you explain that?

SPEAKER 0
Yeah, I mean I'll I can keep this recording and I'll explain that but I will go over it again. So basically there's a relationship between the frequency of a given note and the next one up. So one every key on a keyboard Right? Um goes up by one semi tone and there are 12 semi tones in an octave. So by the time you go up one octave you're back to the same note but you're one octave higher. Okay so um so an octave what an octave is is that the frequency has doubled? Alright so if I started an a um the concert a note for instance is 440 hertz. The one that we were playing first. If I go up to the next a key on the keyboard, I've actually gone up 12 keys. I'm including the black keys here. So 123456789 10 11 and 12. I'll go up and in that space of time in that space of keys I've actually doubled the frequency. So um so what happens is that if I so I actually have a formula here. Right so this is the way this formula is if I go up one of those steps I go up 1/12 2 to the power of 1 12. If I go up 12 steps I actually go up to the power of one times which is multiplying it by two. Does that make sense? So if I go up 12 steps not one step or 12 case I will actually be multiplying my reference frequency here. Bye. Two to the power of 12 and 12 which is to the power of one which is two. So I would double it if I went 12 steps. So another way of thinking about this formula is that the desired frequency? I start with the reference one. So here's 440 hertz. And I want to go up 12 steps to this note here. Right so the number of steps divided by 12. I put two to the power of that. If I'm going in the negative direction, if I'm going down in notes then I just make this a negative step. Right? So um here's an example for you. I've gotta start with 440 Hz. I go up 12 steps. I want to figure out this frequency, it would be two to the power of 12 and 12 which is to. Right? I multiply that and I get 880 Hz. Alright, what if I wanted to go from this reference down to middle C. Or how many steps is it? 123456789 steps. But in a negative direction I'm going down in octave. So I'm going down nine semi tones. So I start with my 4:40 and I go down nine steps. 2 to the power of negative it's almost negative a half. It's gonna be like um 0.59 and then I'm going to go down to 260 hertz. So actually like while I'm recording this, maybe I'll just um just give you an example, maybe we can rewrite this for 40 times power to To um let's just make it 1.0 on 12 at the moment right this is 440 times two to the power of a number of steps. I'm going on 12. So let's let's um let's make it zero to start with. So that would be 4 40 hertz because two to the power of zero is one. Okay. We know what that sounds like. Now I go up by one right to two keys. So these are progressing the same way as the notes would progress on your keyboard. Okay what if I want to go in the other direction? Let's start at zero -1.0 and so on. I go down a whole octave, two octaves. It's gets a load pretty quickly. Alright so I've recorded that anyway but I'll revise that. I'll go over that a little bit but we're gonna look at some other kinds of wave forms that we can generate that aren't signed aside and what they sound like and and so on in the next lecture. Does that answer your question? Thank you. Okay. All right, we'll see you on Wednesday. I'll be in the labs and I'll be bringing midterm papers with me. Don't come look for me. I will come to each of the labs and I will let you know like how we're going to hand them out. It's not gonna be chaos, right? And anyone who's who hasn't done the midterm or the lab test one and was absent because of a legitimate reason like illness. Please send me an email and um if you haven't already, those who have been talking to and we'll be running those makeups in the lab session on Wednesday, starting at 10:30. But you have to come to the sun and 1000 and to be okay. Send me an email because if we run out of space because you didn't send me an email, you won't be able to set it okay? Alright. We'll see you on Wednesday.
