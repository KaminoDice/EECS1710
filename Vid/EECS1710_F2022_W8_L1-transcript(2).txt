SPEAKER 0
Mhm. Um Do you guys see the the screen? You see the slides, yep. Okay, good. All right. Um So we're just we're not we're not we're gonna go back over some stuff pretty much today. Um And so we've been we've been talking about audio for a little bit and setting up tones, so setting up sine waves that are stored inside an array. Um And a lot of that has been playing with how you set up the size of it and how do you get the sine wave to cycle at the right in the right number of samples so that when you play it back it's playing it back at the right speed in time. Um And that has to do with your setup of your sample rate and um and also the duration that you want that audio to play for, which will determine ultimately the total number of samples. And and so that when you play it back at that sample rate um it'll it'll basically play through sample rate, number of samples in one second. Right, Which is what the sample rate is? It's how many samples per second are we playing back tone up? And yes, so for for those of you have made a start on Lab five were basically extending some of the stuff that we've been talking about in the lecture. Um And one of the areas that we're extending Is in the last question and number five we're going to be reading something from a file. So in the last lecture I actually started to talk about um other kinds of objects and I was talking about array lists um but we didn't really get too far into it, so I'm gonna go back over that. So um so we talk about sound objects in order to link our arrays to so that they can play those sounds back through the speaker on the computer. Um And those particular objects we have to import. Remember we're in the last lecture we had to um physically import them because they're not built into processing. Mhm. It's an external library that that has that stuff but other things that are built into processing, we were talking about this idea of these dynamic arrays which are called array lists. Um There's actually a different kind of data structure called a list. And the list is basically just it's a sequence but we have the ability to insert things at certain places in the list. We can um we can think of the list uh moving back and forward through the list, having a position moving back and forward at any one time. It's a little bit more advanced functionality than a straight array. Um We can insert things at the beginning of the list, we can insert things at the end of the list which essentially we can do with an array but we have to create a new array that's bigger if we've already filled our array to do that. Um And you know a raise as we said, are fixed. So there's advantages to having a raise with the indexing and there's advantages to lists that have these other functionalities associated with them. And so there's this sort of hybrid called this array list, which is an array that can grow and act somewhat like a list. So um I think I sort of started talking about string lists and we're talking about this in the context of reading from a file. But what a string list is is it's it's a list object that stores its elements are stored as strings but all of these, so there's an integer list as a float list. Right? These are specific in the sense that um they're all lists that have their elements of a specific type is predetermined. And then we have a general array list that's not predetermined. So the elements of this type of object you determine when you instead she ate it, when you create it and you define it, you actually specify what, what is the thing that it's going to hold as the elements in this in this um collection of elements. And so it's a little bit more advanced to to use but we will come back to this one. We're going to start with the string version here because this is I'm going to give you an example of how you can read data from a file using a list and and have that somewhat processed or somewhat past. You could use an array, but sometimes it's more convenient to use this and and going forward as you get more used to using these types of objects and objects in general. Um it will be, you will find it far easier to work with these things than to work with your own race. Now, if you have to do something low level arrays, always useful to use, um but you know, as some of you are finding probably um and and and I'm sure Julian you're not alone because I have been getting questions on discord and you can actually go back and see through other questions, but things like the shuffle, example, The question in Lab four where you have to use an array to shuffle the elements around? Okay, that is a pain in the butt, it's not once you figure out how to do it, but it is, but one of the reasons that exercise is a useful exercise to do is because you realize um that arrays can be kind of a little bit painful um when I'm so the idea with that lab, by the way, is not that you create a new array and you randomly select from your array that you start with and put elements into the new array to randomly reorganize them, that's not gonna work, why is that not gonna work? Can anyone give an answer for why? That's not going to work. So the idea was that you have an array right? That you start with, that's your input array and you want to shuffle it. And so you have another array the same size and then you with the first array, you pick a random index, grab the element and copy it into the first element of your new array, right? And then for the next element in your in your a you grab another random index, grab that position and put it in. And then you keep doing that until you fill up your new array. Why is that not going to shuffle the existing elements around? Does anyone want to have a a mutant have a crack at why that why? That probably wouldn't work. I know some of you have done that. The shuffle example already? No one. So everyone just like there's a coffee on the desk and I'm linked to the you'll get duplicates good robin, you'll get duplicates right, you'll get duplicates because you can pick the same random number. Like if I've got 10 elements and I'm picking a random value between zero and nine, which is the index on those on that array. I pick a random number. You know, the first time I pick up might be five, I may get some other random numbers. Um but I might get a five again, which means I'm going to put the same element in the new array and we don't want that, we don't want. And the other thing, it's not just duplicates. You might never pick the random number two. And so you missed that one altogether. So what what a shuffle is is normally it's working on the same array and what we want to do is we want to. So I gave you an algorithm in the lab, I gave you the steps of how you could do it, right? So if you read them then that's what you should be trying. Um But the algorithm was, let's take the first element. Let's take the first element. I'm not not so much in reverse when I do this as compared to the lecture, Take the 1st element. Okay, I'm going left to right. I pick a random index from the rest of the elements. So from index one to index nine. If there's 10 elements or however many elements minus one, right. I pick a random number of the other ones. And what I do is I want to save the first one in a temporary variable, copy this one over and then copied the value from my temporary one back to that random location. So I've basically done a swap. Okay, so now the array still I've mixed it a little bit but the array still has the same elements in it. There's no new elements created or some elements lost the same elements. I've just moved them around. Right? So I did a swap and I just repeat that process. I pick randomly again, I do a swap, I pick randomly again, I do a swap. If you do that enough times you're going to end up with a jumbled up array of the same elements. And so that's the idea. But the key to doing that is that you've got to make sure you save that first one, because when you write over it it will be lost. And if you don't save it as a copy, you're gonna lose it and you won't be able to write it back into the other location. So that's kind of annoying. Right? It's meant to be right. So that you appreciate something like you're a list because the ray list has a method for doing that. And yes, it's doing that. You know what we're doing manually? It's doing right. Yes, but it has a method already built for you to do that. So in your coding, you don't have to think about those steps necessarily every time you want to go and shuffle a bunch of elements that you've got jumbled up the order. You can just call this shuffle method. It also has a method to reverse the order. It also has method to sort. So you can sort based on this sort usually works based on the types of elements that are in in the structure. So if it's strings sorting is typically putting it in ascending order alphabetically, because that's how you, that's one way that you would sort strings. Um if if it's numbers then it would put it in ascending order of numerical value. Right? So if it's a float list, it would be in a numerical order. If it's an enlisted will be in a numerical order. Now, if you wanted to be in reverse order you could sort it and then reverse it and then it would be in a descending order, right from highest to lowest instead of lowest to highest. Um Now as you get more advanced in your programming, there is ways which you can define how that sort is going to work and that's typically what you have to do when you're working with array lists of, you know, specialized objects. Um But classes like p vector for instance, if I wanted to have a collection of p vectors, the p vector class has in it. Um some methods that are defined that are used by sort and these methods are sort of standard things that you have to define so that if you want your objects to work well with these data structures, like lists and so on, and you learn a little bit more about how you do that actually in the third course, 2030. So, um in 1710 and 1720 were more interested in how we use these things as opposed to how we define them. Um ultimately, but you do need to have a little bit of understanding of, of what's happening with an array to appreciate all the things that you can do with these structures. Right, So what's the first thing that we want to do with this? Um and the numeric versions of these lists have a little bit more because you can add things together and things that you you know, you can subtract them multiply things that you don't typically do on strings. Um Right, so I had showed this slide in the last lecture and I was talking about a previous example, which was the top example here um of where we had used an array and it was an array of strings. So a string list is similar to an array of strings, but it's dynamic and it's works a little bit differently, it's not an array, so we don't define it this way anymore. We don't use this square brackets to index anymore. Um It's it's an object so it's it's called a string list object and we have different kinds of constructors that we can use to in stan she ate it. We don't instance, e ate it the same way as an array, but we do instead she ate it the same way that we instance she ate other objects like audio sample, like um the string object can be instance, she acted this way as well. Um Okay, so it is a collection of things like an array but we don't we don't use any of this indexing anymore and the way we add things because we don't use the indexing, we use methods to interact with this object. So it has an append method. Um So if I wanted to achieve the same thing as I do up here with this array, I want to add the banana string to my array and I want to also increments how many items I'm tracking that I've got in that array, um I would do it this way with an array but with a with a string list, right? I add the string, but I use this method called the Pent. So at a pen method is usually run to add the element, the type of element, an example of the type of element that that thing holds um to add it and it's called a pen because it adds it to the end of the list. So inside this object it's sort of tracking how many elements are in there and how big it is and you don't see Anything of how that's stored in memory. Okay. And because it's dynamic, it can grow in memory too. So it's probably getting more memory as it as it grows, there's lots of different ways that that can actually be implemented, but that's really something you talk about in 2030, not here. And there's another course 2011 that you talk more about data structures and how they work in memory, but here we just append things to it. So we can append append append notice, I don't need to care about an index and I don't need to care about going outside of an index either because the the the object is sort of tracking all of that. I'm just adding to the end all the time and I can query how many objects are in there by. There's a method called size, which will tell me how many elements are in there. And that method is the same whether using a string list or an array list or an in list. It's a common method and the way that you can actually get an element that's at a particular index. There's a get method. So use a method with an index passed to it instead of using the square brackets. Okay, so fundamentally you interact with this thing through methods as opposed to using the square brackets and indexing on an array. Okay. Right, so um just some examples here, if I've if I've created my inventory according to this, I've got I've basically got banana stick, B. F. G. A bomb, magic potion. I don't know what this game is about, but I've got an inventory of things. I've picked up along the way somewhere in some games somewhere and I've got that as a list of strings basically. And so if I want to output like what I've got in there um I can just I can build a loop in the normal way. Right? I can build a loop but I'm looping now over the size of that list object, Right? Not there's no dot length parameter. Um It's not a string. String doesn't string by the way, it doesn't have a dot length. It has a dot length method to query how long the string is. Um But these string lists use a size method to do the same kind of thing. So I can I can get the range of indexes that I want to use to access the thing this way and then I can print that out. Okay? I can get it and print it. So get will have a return value. That's a string basically on this type of list. If it was an interest it would return an it if it was the return type is the same type as the element that's being stored in that list. Alright. So, you know, if I added them in in this order, a pen depend depend like on the previous slide then when I print them out they'll be in that order. But then I can reverse the order by just calling this method and it will do all of the work for me in moving those elements around. So now when I print them out um they're gonna be in reverse order from the last one to the first one. Okay. And that's changed the list by the way, it's changed the order of the elements in the list. Um If I wanted to sort them, I just run the sort method. Okay. And now they're sorted and they're sorted in alphabetical order because uh you know, their strings and strings, The natural ordering of strings as an as an alphabetical order. All right. How would you limit? I've got this question. How would you limit a string list? What do you mean by limit, Bella you want to just unmute and ask limited in their capacity? So um so I think you can query the capacity but typically what the way they're built in in memory is, you know, one way of doing is to build an array but the array, like when you go to add something and it's it's the index that you want to add too is bigger than what the array, the array is full. Um behind the scenes that might create another array and increase the capacity, double it or something like that. But you don't see that so it's sort of hidden from you. But that's you know, it's usually has a limited capacity and then it expands. If it if it looks like we're going to go beyond it. Um Hassan you have a question?

SPEAKER 1
Uh No, I was just trying to answer her question. Okay, wait, can't you use the size method to get the current size of the array list? You can but that just tells you what the size

SPEAKER 0
is. It doesn't set the size. Yeah, but if you check for the size and set

SPEAKER 1
a condition, you can go over that size, maybe that's how you can limit it.

SPEAKER 0
Yeah, you could Yeah, if you wanted so if you didn't want to put more than a certain amount of elements in your list ever. Yeah, you could have a max size and and you do a check yourself, is that what you meant? Bela you could you could do that, you could manage that so that you didn't, you basically restrict whether or not a pen happens. Right? So it's up to you. You can you can also do that. Yeah, but you can you can append indefinitely up to the point that your computer runs out of memory at least um with something like this. All right. Um Okay so let's get to read back to reading in a text file because you need this for your lab. So um an example. So I mentioned that there is um there is a method okay, Most of the reading from files that you need to do um at least for the foreseeable future, you could probably get away with reading from text files. So basically read into the file. The data in the file is interpreted as strength. Okay. And you can create any file that stores a bunch of data. This could be data that is used to initialize your program to set some of its variables. Right? So you have a way of running your program at different times, you just change a configuration file or an input file and your program reads the file to decide how it's going to set its variables. You can do that. Um And in the lab in lab five, what you're going to do is actually um read in a file that just specifies um Some frequency or basically an index for the keys on the piano for one octave um starting from zero and going up to 11 for the 12 semi times in one octave that we've been talking about. And it's going to use that index to calculate the frequency um of that particular note. And that's like the steps, it's basically the step assuming um that you're stepping that that that number is relative to some reference frequency that you have. And so and and it also has a duration of the note, so you know, as a point, something as a float. And so you could have that and you could specify use a text file to specify a whole melody of notes that can be played with those keys. Um you could have a more advanced version of course that has more information in the file that talks about which octave and which key index of which octave on the keyboard. Um I think there are about eight octaves on a standard size um and a full sized piano and an 88 key piano. Um So so you might have another piece of data that says instead of black red, green and blue values, you could have an index an octave, a duration and maybe some effect like we were talking about in the last lecture about staccato or something like that. So you could have that data specify and you can have a whole melody laid out right of notes and that you read in and automatically your program reads in generates notes, plays a note and basically plays back the melody from the file. So in order to read, the simplest thing we can do is just like the split method that we know took a string and divided it up into words. Um depending on whatever character we said was the space character. Um you've got this method called load strings and what this does is it splits up all the lines in your file. So this each new line is treated as one big string and it is read into the next location in this string array. Right? So very easy to use very, very straightforward. There's a lot of work that sort of, you would normally have to do setting up a link to a file in pure java that you don't have to do here. It's already done for you with this method and it will just fill this thing with the strings from your final but then of course you've got to go through and process that data. So let's look at an example of what we can do. Now notice this data purposely has a whole bunch of lines in here that are empty and you know, maybe we don't we want to get rid of that. Okay, that's not useful. We just want these colors and what I'm going to do with these colors actually is just um right the label, the word and I'm going to use the color to write the label in an up window. It's just a nonsensical kind of task but just quickly gives you an idea of how to do this. So so I've got a method here called read text file and I'm just gonna go to the to the method um read text file and can you see that? Okay. Do you want me to make it bigger? Does anyone want me to make it bigger? That's good. It should be easier to see on on your screens now. So um so what I'm gonna do is I've got a file name. So this file name incidentally is the file name of a file that I'm going to store in. So here I'm in the directory for this this sketch. Okay. This sketch um I've got the pd file for for this one and the pdf file for this and the folder name, is this the sketch folder that these are sitting in? Um It's called? File io right so it doesn't have to have the same name as any of these files that are inside it. Um and and I've got some other files in here colors. Text colors too. Dot text sample one dot text which is the one from your lab. So I can just um display those files. I'm just going to do this in the command line here. So this is the one from the lab which just has the index of keys and the duration of some simple notes. Right? Um but if I look at the colors file, okay, it's the one that's in the example of the slides. So how do we read this data in? Well we need the name of that file. Now, that name of that file is is um that as long as the file that we're running okay. As long as the file that we're running. So in this case it's read text files and text file er I oh they're in the same sketch directory. The file that we want to access is in the same sketch directory. We can access it by directly referring to its name. We don't have to say where it is in our file system. What folders? It's part of or anything. The first place that any processing sketches going to look for a resource. This is the same for audio files that we want to load. Right. We're talking about this in the last lecture is directly in the sketch someone brought up that you have to have it in a data directory. Well if you make a directory um inside um this this directory a subdirectory Yes, you can you can put files into it and look at it from there but then you have to refer to it from that directory forward in when you write the name. So here for example I'm going to call this, I'm gonna run this with colors text. I'm going to run this read text final method, colors, text. If it was stored in data I'd have to have um data, um forward slash and then the file name. So I use the normal file path. If I'm on windows I'd have to use um the proper file path to access it. So the easiest thing is just to have it directly in that sketch folder. Um and then you can access it. So when we look at some sounds and things that you want to download from the internet. This is how you should put it into your sketch. You just put it in. If you've got a lot of files you need to organize, then maybe you organize it into subdirectories. But remember to access it you're gonna have to access it through its subdirectory. So I'm gonna pass this file name to my read text files method. So now this variable here is going to hold that file names. And in one hit we're gonna load all of the text strings including those empty text, those empty lines into this array. And what I want to do here is I want to take a string list and build up the string list. Um I want to add all of those lines to the string list only if they're not empty, Right? So I want to test the strings to see if they're empty strings. If they're empty strings, they don't have any um values in it that I need for my program, I'm going to skip them now. That's an example of pausing a text file now. It's not that's a simple passing because it's just getting rid of empty strings. But you might also keep some strings for certain information. Keep other strings for other information and that you might want to sign into different variables depending on what's what the content of the string is. That's also passing. You're basically sifting through and filtering and seeing what you extract and what you don't that you want to load into some variables to use in your program. Right? So um I start with this array. Right? So if I check its length, if its length is um it's not greater than zero. So it's it's a non zero. I mean it's a zero length array. Like the array didn't get filled with anything. I'm just gonna exit out of this. And because my method has a return type, I'm actually going to return null and that can indicate to any method that's calling this that um that you know, it didn't get anything from the file um there was nothing red. So there's nothing to do. Um So as long as I don't return, I must have had something in those lions. So what I want to do is I want to create a new string list object. And I'm gonna also count the number of empty lines and count the number of lines that are non empty. So I'm gonna start that at zero and then I'm going to go through that array and look at each line. Each line is a stream and I'm going to do a test, I'm gonna say because this each element in this line is a string is a string object. We have access to all of the methods that are available on a string. One of those methods is empty and another one of those methods is blank. Right? It's not empty. But it's like white space or something like that. Like a space characters or tab characters or something like that is empty. Is like there are no characters. It's just a new line character. And so I'm checking both if it wasn't empty. If it's not is empty is empty returns true if it's empty or if it's blank. So sorry if it's empty or it's blank and it's not either of those. Right? So I've got to knock out the front space that out so you can see, right? Um If either one of those occurs, I don't want to add it to my I don't want to keep it I want to get rid of it. So if it doesn't occur then I do want to add it and I'm going to append that line. Um and I'm gonna add that. I found a line that has text in it. Now, if this test fails, so that means I did find an empty or a blank line, then I want to count how many lines I, you know, I want to increment my counter for the number of empty lines. Okay? So and then at the end of that I just print how many were empty and how many were not? And when it's very convenient to use this append with an array list and if I do need it in the form of array, I can always convert it back to an array because these lists have a method that can convert all the elements into an array version. So it's convenient when you don't want to worry about the size, but then when you want to convert back to an array, it will create the right size array for you. And I can just return that as an array because I have an array type return here. Um I could also just make this a string list um directly if I want and just return content. All right, because this is a string list object. And I could do it that way as well. All right, keep it the original way. Okay, So, so I that reads in my file, but I've also processed that at the same time to posit right now um I'll run this because in inside that file we're out putting how many empty lines. Right? So I ran this previously and there were eight empty lines and eight non empty lines. And this is what ended up being passed back um after we passed the thing. So you see all the spaces are gone. Right, So I don't have the lines anymore. Um Okay, so the next thing to do is I've got the lines that I want now I want to extract the information from them. Right? So here all I'm doing is I'm going through that that list that I ended up or that array. If it was a list, I could go through it using a loop and set by to go between zero and size. One lesson size. And I could use the get method with I as the input to extract each element here because we converted it back into array. And you're used to working with arrays. We can now just iterate over that array. And what I'm gonna do is I'm gonna print the line right? Which is what I did here, I'm printing all of those lines but I can also process all of those lines. So I can I can split that token because it's got remember the file actually has um it actually has four things on each line. It's got a string for the label of the color label and then it's got the red and the green and the blue values, integer values. So here what I've done is I've just split each line. So within the loop I grab uh each line which is in this array here and I split it into several tokens which is another area of separate strings. And then for each one of those strings, if I know what the order is, I can then go and convert it. So I know the first one is a string. It's the name of the color. So I can set that first token to a variable that I want to store. The color name. Okay. And then I can um I can extract the other tokens which are strings also. But I know that there's strings of integer values. And so I can convert those strings into vintages right now. If the string has some kind of decimal place or some character that's not numeric, then I may get an error there. Um So there are ways that I can test string objects to see. There are methods on strings that can test whether it's numeric, whether it's alpha, numeric and so on and so forth. Um Alright, so I extract all of those elements red, green and blue which are the 2nd, 3rd and 4th tokens. The first token was the name and I passed those straight into a method that's going to generate the integer value of my color and then I'm gonna set my stroke. Using that color. I'm gonna set my fill using that color. I'm gonna set the text size and I'm going to print out the label at a certain position on the screen. I'm gonna change the position for the next label. And when I run that out I've turned that text file into a graphic. Right? So you could do the same kind of thing with coordinates. You can store them in a file and read them in create um vectors or some variables for a line. You could have a line per um per line in your text file. You could have keywords like line, circle whatever that tell you what shape to draw. And then you could test that string to see what value it is and then based on what value it is, you could have an if statement saying if it's this, if it's line or its circle then you have a method called to draw the circle and use the data for a circle input. Um So this is a way like for storing like these data files, you could store text strings in the data file as well. We'll talk about that later but you could save a version of your picture in a set of instructions format or a set of data format that you can then read in and re draw a picture for instance. Yes you could save the picture of the picture as well but the point is you use this for more permanent storage. Um The memory doesn't sort of the variables that you assign values in memory. Don't stay there forever when the program starts running, you lost it. Right. But if you want more permanent storage, you work with the file. So it's very important to learn how to read things in and out from files. Um You can also store a ton of data in the file. Um and then only loaded into memory when you need it. Okay, so that's sort of just space things out, you know? There's a little bit of overlap there with some of the letters but um it just took the data from the file to generate that. All right, okay. So I've got another version of colors to where? Which I won't run at the moment, but it uses a Y position that's set by another token. Right? So a floating point value is read in from colors to so it has another value at the end which just says what the white position should be for each one of those labels. And so you get a slightly different results but you can muck around with that file to see. Alright. Um So so that's reading in uh and reading in files. We've got about four minutes left. So what should I talk about? I'm going to jump to an example. I have a couple of examples here of um setting up chords that's in the code that's uploaded. So you can have a look at that one. This is basically the same as, I don't think I have time to run this one, but this is the same as when we added to wave forms together to get beat beats effect when you're adding to frequent different frequencies together. It's called a diet. But if you're adding three you get a triad and and there are a lot of chords that just involve three. So one of them is a major and that particular example goes through, it shows you how I plot, plot each of these multiple um wave forms and then the resulting one um and plays the chord as well. So you can have a crack at that one. Um What's more interesting is when we start to play with sounds that we want to get um and incorporate into our applications. So I wanted to point out that there is this um there's a couple of good resources for getting actually that it's more than just sound. Um You can also get have I got the link opened up here. Let me see. Well it's the other way here we go open game art dot org. And you can go in here and look up, you can you can start an account, It's free. It's open but people post, you know, different artworks and two D. Graphics and three D. Graphics and sound effects and things that you can use music and so you can go and look for. Um So there's one here um A level up sound, all kinds of level up sounds all in one audio file. Um I'll just stop that. Another one here punches. Um And you can look for music as well, there's music files um different effects um and so on and you can and you can have a look at these, they're all audio files and you would load these in using your sound file objects. And we looked at an example of that previously. So the example because we're almost out of time that I wanted to show you was um So first of all when you download these these you may have to convert them into a format that this library can understand. So if you can find wave files that's probably the best thing. Or mp three files um this library can understand those. If it's other types of files, you may have to convert them into mp three's or waves or I think a I. F. F files are also understood and so the example that I wanted to show you. Okay, so remember we did that that hit the target thing where we were launching the projectile at the target, so say we wanted to have some background music and this was part of the game and um I actually have two different files here. There's a file here that I'm going to use for the background music while it's going on and then another one that I'm going to play when we actually hit the target. And I also have another sound which is a sound effect of a grown just some random sound effects that is going to occur when we hit the target. Okay, so so we set these up, they're all sound files notice, so we instead see eight new sound files, we point them at our files, these files have to exist inside the same sketch directory. And then um I take the first one and I'm gonna run that as a loop, Right? So that's gonna be the background music. I put that in my setup and then remember we we had all this stuff for project for controlling the projectile, We looked at a vector version of it. But ultimately in this um that we had a method called move Projectile, we're testing to see whether the Projectile had a hit or not. And previously we just set a flag to say that it was hit and we used that flag to stop drawing if a hit occurred. Well, here, what we're gonna do is we're going to have all of that still, but we're also in this, in this if statement, right? We're going to test, we're going to play a sound effect for the hit, we're gonna stop the original music and we're going to start the new music? Okay, so I'll just play this Mhm. Can you hear that? Okay so I can you know now I've got my little game, I want to try and hit this thing and wait for it. Okay um and I have reset as well but I just wanted to show you how easy it is to get up and going with connecting sound effects and this could be downloaded sounds sound files, you could record sound if you've got a microphone, you have some software, like some sound garage band or something and you recorded um some audio on Audacity, there's another one. Um but you could just use um sound recorder if you're in Windows or something and record some sound. Uh save it as or convert it to a way format. And you can embed it into your your program very easily using these objects. So this is um this can start to enhance. Like once you get a handle of how to work with objects all of a sudden it's a matter of just finding an object that can do what you want, understanding how to construct it, understanding what you can do with it. Like how do you invoke methods on it to make it do certain things and looking at the documentation and then that's it. I mean you put these things into your your program and to some extent you embed them within loops within if statements within any of this control flow to start to enable their behaviors when certain conditions happen in your in your program. Um Okay so um I think the rest of this um this lecture starts talking about another like looking at frequency effect. So um I don't know maybe I can just play it for you but we've sort of finished time wise but maybe I can just play something for you to show you what I what I am talking about in the last couple of lectures. Um Alright so this um um so there's another object called that can look at your sound file. Um Not in um not in the time domain because we've been plotting our sound files in the time domain, respected time but you can also look at in the frequency domain. And this is sort of this is like looking at a graphic equalizer view. Right? So you have a base channel and you've got all these different midrange channels and you've got like a travel channel. So you're looking at the frequency content that's in in your sound files. And basically what the frequency is is basically how much of a particular tone is in your file. So for example if I have one tone in my file in my sound um wave then it will only have one frequency in the frequency view. So one particular frequency like the single tone, 440 concert day. If I have two tones in my signal I'll have them shop in two spikes in my frequency view. And if I have three tones, you know, if I've got more of one tone than another, you know, its amplitude sort of relates to how much how much of that particular tone is in this signal when I combine it all. And most audio music signals will be some combination of a whole range of different tones. And what this object does is it actually creates this frequency view for you. So if you've got a lot of spikes down low, that base, a lot of bass in your signal. If you've got a lot of spikes really up high, then there's a lot of trouble in your signal and and you can visualize that. So there's another object here. This is quite a mathematical operation if you wanted to do it yourself. But because we know how to use objects and someone's written an object that does this for us, we can easily use it by instance creating it, connecting it to our audio sample that we want to play. And I think in this one it is what sound am I playing in this one? That same background music, Right? I play that and I link up this object and and all of a sudden I've got for that same audio fund, I've got a way of looking at all of the frequency confinements in that environment. So when there's spikes here, I've got more sharp sounds spicy sounds, I'm sorry, so you've probably seen a visualization like that before. Um But again, like as we start to expand and use other objects in the audio library, it's just a matter of learning what is it that that object is doing and how do we interact with it to make it do that thing and then how do we construct it? And then we can use it with the programming school we have, we don't need to understand how that particular object is doing what it's doing. Okay. It's abstracted from us, but it's made available to us as a library as an object with a set of methods that we can use um to make it do stuff. Right? And so anyway, I just wanted to give you an idea of some of the things that you can do with audio and we kind of ran out of time. As usual. I'll stop the recording here, but I'll take any questions before I do that. If there's any questions from anyone, um if color text file is on my desktop would be used, could we copy that as my directory, You'd have to copy that file into your sketch folder. So there's no way to access your path outside of your sketch folder basically in processing. So the best thing to do is to take that file from your desktop, put it inside the same folder that your sketch is that's trying to call it is running from and then um and do it that way. Okay. I think that was how how can Anson will the next lecture be online as well? No, so monday and Wednesday is not going to be, but I think I'll make Fridays in general online if everyone's okay with it, I'll check with everyone physically on monday and Wednesday but the friday sessions because there are a lot more like looking at code. Um it might be and playing with it and changing it a bit easier for me to sit at the desk to do. That's probably a bit easier for you to look at it as well without having, you know, on a lecture on a projector in the next Um what does the parent parameter? I'll stick around and answer some questions. So if you want to leave that's fine. What does the parent parameter to do in sound file constructor. Okay, so this is um this is something you learn about later in 2030 but the sound file is connected to the application that's running and that's kind of apparent object if you like. And it has a reference in memory two. And one way to connect that and that's, you know, these sound files need to be connected to an application when they run um is one way to connect that is too, there's a built in reference to um uh the object that this thing is running within and it's it's kind of a built in reference to um the application itself pretty much. Um That's all I'm going to say about that at this point. But we will we can talk more about the this keyword in 1720. We will actually yeah, it's it's a way that you're bonding this. Um It's because the application when it's running has access to the audio, has access to the events from the keyboard and hardware computer and so the audio file needs to know how to get access to um to the sound card and everything. Um And and so in that particular library there's an explicit link there um It's the reason it has that is that you could potentially link it to different windows that are different applications, so that one could take over the sound card, one could take over at different times, so you won't need to ever use it other than using with this as the keyword, so you always use it that way. But until until we learn some deeper stuff, you won't you don't need to worry too much. Just follow that. Yeah. Okay. Are there any other questions? If any I can stop the recording. If anyone does want to stick around and ask anything, just raise your hand and I'll hang out, hang back a little bit
