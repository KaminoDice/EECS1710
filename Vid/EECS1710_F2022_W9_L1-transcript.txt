SPEAKER 0
Okay, we're recording guys. So before I get into the lecture I just wanted to um ask because I think there's still quite a few of you still working on Lab four, it's not due until tomorrow, but it seems like the question that everyone's having fun with is the shuffle question, right? Um for question one, where you're doing the line art, you can create any pattern you want as long as it's straight lines and there's loops involved and it's inspired somehow from those first two ones that you have to do, you don't have to make the patterns that I've provided for you. Um You can choose one and try to make that. Um But ultimately, if you end up with something, you know, some abstract art, shall we say? That's fine. Also, okay, it's practiced with loops. It's practiced with a raise later on in that lab. So um yeah, if you've got something going, don't don't burn all your time and energy trying to get this perfect thing that we're not even necessarily looking for. Okay, there's a certain amount of I want you to do a particular thing right? To force you to um sort of be able to build something that, you know, you've got some spec in mind, right? And then there's a certain amount where you can go nuts right now, for Lab five, how many people have are onto Lab five? And are working on aspects of Lab five, there's quite a few questions if you get to the end of lap five is just working with the arrays. Ok. Um so I was one, a couple of things I wanted to point out and I will do this on the board but um when we did it, when we did the sine waves in lectures right? We looked at basically one cycle right? Which was and then we did like a sine wave, there was a perfect fit within that cycle and that cycle was your sampling rate. Right? The sampling rate was 44,100 samples. Right? And and now we're doing something where we've got a longer duration, right? It may be longer, it may be shorter. Right? The duration and the sample rate together tell you how many samples your array is going to be. Um And I was talking about, well, how how would you make this thing repeat? Right now, I was talking about using a mod operator. Can some of you in the lab, I was saying you can make this repeat on mods Using a mod. So your eye is sort of bearing I is bearing from zero up to some value. If it's bearing all the way up to your num

SPEAKER 1
samples, okay?

SPEAKER 0
Um it's gonna be varying and you can make this thing repeat using a mod operator dividing by the separate. Now that's gonna that's gonna force a repeat. Even if this wave form does not fit perfectly. Right? It's gonna start again and you might get this type of effect. Okay, some of you probably already found this now um you don't need the mod operator is all I want to say, right, if you want those to repeat, um if you just continue with I um changing the frequency, will just change the shape of this thing altogether. Okay, so if you don't want this discontinuity, this weird sound, if you're getting a weird sound could be that other things that contribute to weird sounds When you're adding wave forms together, there's supposed to be between one and -1 when they played back. When you press when you run the play method, It's expecting that the white form that you're playing is between one and -1. So if you're adding waveforms together that have been generated this way and they're much larger than that, it's going to you're gonna clip or you're gonna saturate the the amplitude on on the audio and you're not gonna hear these variations too well and it's it's just gonna it's gonna be, it's almost like we're gonna have something like this is gonna be flat flat, so it's gonna sound weird, right? It won't sound soft, it'll have these discontinuities, they always show up as like high pitched sounds right, whenever you got discontinuities um So watch out for that, Okay, and the other thing is um what else was I gonna say, oh, when you get to the last question right and you're playing back multiple notes, Right? There's basically two approaches, you can create multiple audio samples or you can just create one big wave form that combines all of those notes together if you're having trouble or the sound is not, you know, the sound is a bit, it sort of sounds good at the beginning and then it gets worse as we go along, processing has some kind of quirks in it, where if you have too many audio samples going, it doesn't it doesn't have an issue with sound samples that are playing from a file, but for some reason the audio samples, if you have too many of them going, it can sound a bit crappy. Okay, So can I recommend to you, especially if you haven't done this yet, If you haven't any trouble with that so far, just make make the audio waveform. Just combine all of the notes together and make a longer audio waveform and then connect it to a single audio sample. Okay. That way you don't have to muck around with, like, the durations are used to adding more samples. Okay, you're going to have to do this with an array, right? If you've looked at the slides and understood what we were talking about with array lists, you can use a float list and easily take several arrays that you've generated for each note, and you can add when you use the add function, you can add a whole array of values, um and append them together and then get the final array out at the end. So you don't have to manage the size of your arrays. Okay. But otherwise you can just do it, you can just go through all of the race for all of the tones, add all their lengths together, figure out how big of an array you need to make and do it that way and then just copy the values over. But array list, float list is so much easier to do that. Right? Okay. Um any questions about labs related to that? Okay. Um there are lots of questions being asked on discord and lots of answers being given. So sometimes I'll refer you, I'll say please scroll up because I've answered this question about five times. So scroll up and have a look at what's been posted. What the answers are two questions. Things that have happened with people's code, you know, you might be getting similar errors. Alright. Um the last thing I want to say about audio, obviously we could I mean I could spend more and more time just going into what else is available in an audio, but I'm not going to because processing has lots of examples. Okay, so um sorry, I can't make the text larger for for the the java examples within processing, but if you go into processing and your open examples, Okay, you can go there's examples in the library section because this the sound stuff is not built into um processing. We're importing it from an external library and then there's a whole bunch of different examples you can look at okay if you want to learn how to use one of the other objects. Um And we have a project coming up so um I guess I'll make an announcement about that now and then follow up on Wednesday. But basically for the project um you need to explore some building an app that combines, it's a little more specific than this. And I've got a couple of um directions you could go but you've got to put together some combination of graphics, image and audio right? For some purpose it doesn't have to be animation or interactive necessarily. Like you might create some some artwork with with some background audio you could have simple responses to mouse clicks and stuff like that but I'll give you the actual some example things that you could do but the project has to combine these elements but you can work in groups. Okay. So I need to post something on e class where we can all um you can actually submit who you want to be in groups with. We've got to do that over the course of the week and I think maybe the best way I can do it is to automatically assign everyone to a group. Oh no. And then and then you request can I group, can I move from group X. 2? Group Y. Right. Based on those assignments. Okay. Um And then I can I can move people around from there. Okay. So it'll be a chance for you to work on a common it'll be a common mark for your group for the project. Alright. So um I'll talk more about, you know, you're allowed to sort of use some code from online but as an inspiration, you can't just lift it and use it and submit that you have to also indicate where you're getting like your sources, but you have to manipulate in some significant way if you're gonna do that. Okay. All right. Um Back to this. So a couple of these examples, I mean you just pick them up and and there's one here, for example, that's um using audio directly from the microphone, input on your computer. Um And so, you know, because there's these examples just run and play some of these examples, so this one's just picking up my the volume in my in the sound is picking up. Um and it's just drawing a circle based on the the amplitude of the sound. Uh And there's a class there where you can extract that information from the audio as it's coming in and it's using that as a parameter for graphics. Right? So this could be something that you do um for your project, obviously, you know, you're controlling something else maybe. Um So these examples, it's pretty easy once you understand how to work with an object, it's always the same I construct the object. I call methods to do stuff on the object. That's it right? You gotta read what it's doing, right? And look at some examples probably for how to use it but it's pretty straightforward. Um And here's another one which is I was talking at the end of the last lecture about the frequency domain and um I recorded on a little bit and finished that discussion about what it means right? If you have any questions about that or you want to do anything with that? Um Further just ask me about it. Okay. Um But there are some examples here where there's some

SPEAKER 1
filters and this one you can't really hear it. Okay we've got some white noise. White noise has essentially all frequencies because you know sometimes you don't know how it's changing. So it could be changing like a really fast sine wave or it could not be changing so much. Um Usually has when you hear this study sound from lots of different frequencies that are in your signal. And remember when we look at the draft at the end of the last lecture where you saw um to the left of the graph. But this is in the frequency domain, to the left of the graph is lower frequency and to the right of the graph is high frequency when you exactly basically frequency or you know the frequency of find ways that are present in the sound that you're listening to whether it's music or whatever else. And the filters this sugar examples, this bubble is just basically with part of that. Am I keeping from the sound? And it's just so I'm keeping it either high frequencies and those frequencies or keeping somewhere in the middle. So there's lots of interactive examples where you can explore how to use those built in objects to filter audio if that's something that you wanna do. Okay, we will do you will do more of that

SPEAKER 0
when you do your uh digital media um You're that course the sorry, media signal processing, I think that course you do next semester and you'll be but you won't be doing it with this tool. You'll be doing it with another tool called max where you just plug blocks together and and do this sort of stuff. All right. Um Okay, so so there's a lot more that we could do with audio. I've got some time at the end of the course that maybe we can pick up on a couple of those, but I do want to spend the last bit of the course may be talking about how we're going to transition to the tools we're going to use in the next course. Right. And how do we for those of you who have run java programs? Not from processing before, but from another tool. How do we run in these other tools which are industry standard tools, but also access all the processing stuff that we've been learning. Okay. All right, so today um we're going back to uh images. So we're going to focus on just some simple, just the simple aspects of getting up and running working with um image objects. So in processing and processing image object, it's called p image. Um And it basically stores um data that we whenever we present this data, it's always presented spatially. It's presented in terms of X and y. Um set of pixels. And it relates to this kind of concept of the two D arrays that we were talking about that we started to introduce. Now the nice thing is the nice thing is unlike when I had to work with images and I had to work with things like this. Right? And build up images. You know, build up something like arrays of arrays in memory to work with pixels right? By using these indexes for the iron for the width and the height of where a pixel might be in this. You um you don't have to deal with this low level when you're working with with objects. So um but you do typically you do still want to think about iterating over just to keep it um to help it maintain sense right? You still want to think about iterating over X and iterating over Y. Or iterating over I. N. J in image coordinates. Right eye's going horizontal. J is going vertical to understand how or where we're looking in an image when we want to access um data from it. But you won't have to deal with these two D arrays so much. Alright, um so we also know at this point that in an image the each each position in an image is stored as a color, Right? And we know a little bit about color. We know that it's comprised of three values and we know that there's lots of different ways that we can specify color. Right? So even back when we were drawing graphics with that, what was that tool called again? The someone introduced me to it and then I told everyone about it, um the vector graphics one where we were drawing, what was it called again? Yeah, sigma. Right. So um so even with that tool like it could tell you colors in terms of this hexi decimal value. Right? And we saw we haven't really talked much about this representation so hopefully we'll clear that up a little bit. Um as we start to talk about images. But you also noticed that color information, who's noticed that you could represent it as a single integer as well. So even though color is comprised of red, green and blue, which are all in all images or float values, they range between what value colors range between what 0 - 55. Right? But there's also an integral representation of a color that combines all of that. So how does that work? We'll talk about that. All right. So, let's start with something simple today. Um Let's look at this image object. Okay, So essentially um the p image object is not necessarily related to the application window until you paint that object into the window. Right? So you can think of this as just a storage, just like your audio. It doesn't relate to the sound card or making a sound until we connect it to an audio sample. Right. Um And we we just use a raise for that sort of thing, but in an image um there's a lot more going on. And especially with these pixels and stuff. So um we can use an object to represent an image. Um and that's this p image object. And if you look at the help or the reference manual for it, P image is actually stored within um processing. It's built into processing. So you don't need to import anything like we did have to do for sound. Okay, It's automatically available that we don't need any imports there. Um and it's got a couple of fields right associated with it. So once you load in an image. So typically you loaded in with a method called um load image and that will generate a new p image object and then you can assign that generated in memory and let's sign the reference back to the p image. Reference that you create. Um Once you've loaded in an image, but we can also create our own images. We can create an empty one. Right? And we can paint it ourselves. We can paint all the pixels and and make them um whatever colors and wherever the colors are ourselves. We can also um we can paint things into the application window and because that effectively is an image that's being stored, that data is being stored. Um we can extract that information and use that um to generate other images as well. Right? So there is a way that we can use these p image objects not only to load images in or but to create our own, but we can actually paint lots of different things with all the graphic stuff that we've done so far, Lions and all these patterns that you're doing for lab for for example, we can paint them to the the window of the application and then we can extract them as as an image. We can actually take that data and we can save it as image files so we can generate our own art, capture it. Uh save it as images. We can even do this over time and create image frames that we might use for a video if we wanted to animate something. Okay, alright. Um Okay, so the load image and the create image are the two methods that we use typically to get an image object up and running. So load images used when we have an image and we want to load that in from a file. Right? Same. This is analogous to the sound file object where we create, we linked it to a file that was in our sketch. Okay. It has to be in our sketch. If you look at the help on processing, it says that it should be in a folder called data, right? Does not have to be, it just has to be accessible from where the sketches. So any sub folder or the immediate folder that your sketches in that's trying to refer to it. It has to be in there. All right. Um and then create image, creates a blank image and then to display the image. Right? This means we take that image data and we paint it to our application window basically. Um we use this image function on this image method and there's a lot of different ways we can use that, but we can basically position the image, we can resize it. Um and the way that it works is basically the same as something like the wrecked method, right? But instead of drawing a box, it's going to draw all the pixels to the within that box, within that size that you specify from the image into the application window. Alright, you have an image mode which just basically sets how you want to interpret some of the parameters that you pass to this image method. Alright, let's look at a quick example. Alright so we've got an image here that were ripped off um your queues website full of images um of different parts of the university and we've got an image of the lesson building here. So it's as simple as using the load image, right? That's going to create the return value for this is a P image. Okay, so we have to have a reference created that can refer to it. So we assigned this to this p image and now we refer to this image object through the reference my image one. Okay, so when I want to draw it, I don't have to draw it in the draw window by the way, I can paint it a single time. This is much like the background method, right? I paint the background of particular color. It will paint the entire um size of my application window that particular color. But here um when I paint this image, if I'm using the corner mode for example it takes two coordinates which just specify the top left corner and that will use the image data to understand how big that images in pixels in the X and Y direction. Right? So it will paint it however big it is, it's not going to fit it perfectly into your window. You also have to know how big that image is to be able to set your the size of your window up to fit that. But what we can do is we can um once we've loaded an image we can actually query that image um to see how big that is and we can we can stretch it, we can basically um change the size of the image as it's presented in the window so it fills out application window, right, that's possible. Um Just as another version of loading this image onto the application window or displaying it, if we use the center mode for example then the coordinates don't no longer refer to the top left corner but they refer to where do we want the center of the image to be placed in our window? And we're placing it here at the center of our application window. Right? But it's going to use the same size that's built into the image to draw that out. Now this this works whenever I call this image method, it's painting one time. So if I if I called it again with the same image but I changed where it was going to paint, it would just paint over the top. Okay so it's changing the pixels that are in that application window directly um depending on how we paint it. So if I want to paint a background image then a foreground image. So I've got a character that's running around in a background but I want to use an image for that. Okay I need to make sure that I paint the thing that's in the foreground last. Okay And I can do that in my draw loop. If I'm going to update the position, I might redraw all of that so that I can move things around um and have that kind of interactive feel. Alright. Um So I can also like modify how big that image is. Right? So there's different ways of calling this image method to modify that. I think I've maybe I'll just run the code here. Um Okay, so I've got an example here actually I'm gonna unlock all of them. So I'm going to draw the first one in the top left corner, the same image again in the center and then over the top of that I'm going to draw a smaller one. Alright. So I can do things like this. All right. Now, once those images are painted into the background. Okay. I'm now I've now got a composited image. Um I can't go and you know, if I wanted I could go and access the pixels here as I see them. Or I could go to the image object and access its pixels independently from what I'm showing on the application window. So if I wanted to change the pixel data associated with the image object, I could do that if I wanted to change what I've painted or the pixel data associated with um what I've drawn to the application window. I can do that also write independently. All right. So that's pretty easy to get up and going. So we can also create a blank image and we do this with the create image method. This will just create a p image object but it will have essentially zeros right, for all the colors. It'll have black basically. It won't be initialized with anything. Um well it would be initialized with black which is 00 for all of the channels. Um So we can specify that. So, if I want to create a new empty canvas but I don't necessarily want to display it. I just want to run a program to generate some image um you know, by using loops and so on. I can I can do this um There are also different formats for your p image. So you can specify just an RGB image. You can specify an alpha with RGB that has that extra channel. Um Or you can just specify a grayscale alpha type of image. So there's different ways you can create that. Ultimately they all store colour data in a 32 bit integer. Right. Alright. So let's look at an example where we create an image. I've got the naming in the code that I've uploaded slightly different. Um Okay, so um I create an empty an image but it's empty. Right? So how to actually set or access the pixels in that image object. So the easiest way to access and set values is to use these two methods get and set. Okay, so I have a reference to my object. I have a loop that loops over all of the pixels in the width and the height. I can get those properties from that object once I've loaded it in. Right. Two properties will be set up, right? They're available to you just like when you um use the size method. The width and height values are automatically available to you right? Um to utilize to sort of know where to draw things on the on the app window. So same thing here they're available to you as part of that object once it's been loaded in um here we've set them in the previous example. Same thing uh whatever this image has whatever its X. And Y size would be. In terms of pixels once that's loaded in that will set the width and the height of that image object. Okay. And then so then you've got you know how big your M. And your N. R. Right? Um and your N. For that two dimensional um representation. Okay so the way we get we get them we can we I think the easiest way to do this is to keep these um nested loops. Right? So you have the those two indexes independent from one another. If I want to go over every pixel I have to go over all of the X. Direction. Like the I indexes. Right? So from zero to width of that image object. And then I want my J. To go from zero to height right over that image object as well. So I need a nested loop so that inside that nested loop I'm exploring all combinations of I. N. J. To look at every possible um position in that image. And so to get a pixel um I can I can use this get and the pixel is basically as I said stored as or color values are essentially stored as images right? So I can get the color value. But this representation when it's an integral form is a little weird right? It's it's not any of the colors specifically but it's got all of the color information embedded within it. Um So I can I can grab the pixel value. I'm going to do something with it in a second. That's how I access it. Or I can set the pixel value at that location to a color. Right now I've got I've created a color here and we're not really using this line unless I wanted to print out that value or do something with it. I'm just using the second line here and I'm setting the value to read now. This is 300 by 300. The window is 600 by 600. Okay and then I'm going to print that image out to the window or paint it So that the top left corner is in 00. So it's only gonna take up a quarter of this image is 300x300. Right. But I'm setting all of the values to read right by going through all of the range of I N. J. Makes sense easy. Right. Much easier than working with a 2D array. Although you know you still have these nested loops. Right? Okay. So um what if I try to print out this pixel value and because that's a lot of pixels. 300 by 300? Uh I'm just going to choose um the pixels between a range of I because zero and 10 and for a value of J equals zero. So just some of the pixels I'm gonna print them out and before I set them I'll print them out and then after I set them I'll print them out and I don't know if you can read that. Can you read that? Um There is I'm getting uh quite a large negative number before I set it for all of these pixels. And then I'm getting a slightly a still large but slightly smaller negative number when I printed after I set it to read what's going on. This is why why are we getting these weird integer signed integer values um When I try to print out the value of the pixel so any ideas for that. Okay, make it a little bit bigger for you, you say that? Is that a bit better? So what is this? What is this? They're not addresses their actual integer values but why do they look like that? Yeah know the location is given by I M J. In fact all of the pixels that all of the pixels in the image are here and we've colored them red. So before that there was some other color. Right? So afterwards presumably after we've set them to read and then we look at them again. This number here must somehow mean red Right? Like red as in or the way that I defined red was you know, full 255-00. So what's going on? Like it's one value but it's storing all this information so it so remember let's go back to the representation of a car. Right? It's we have color um colors typically held in three channels and we know that each channel is eight bits because eight bits gives us a range of values between zero and 2 55. Okay. But that's not convenient. I've got three different values for every pixel location. I need three variables. Right? It's not convenient. Um but it turns out we've got this integer but the integer has 32 bits. So for each channel we only need eight bits three channels. That's 24 bits but we've got 32 bits to play with. And so the representation basically divides up into sections of eight bits and uses each one of those sections to represent um each one of the colors. So blue is stored typically um in the first eight bits green is stored in the next eight bits red is stored in the next eight bits and then we typically have an alpha channel stored in the next eight bits. Okay. So what does that mean? If I'm getting remember integers? These are using integers. And what do we know about integers? The first bit or the largest bit over here? What was that? I mean into just represent positive and negative numbers. Right. And what's the range? Probably can't remember the range. But if there's 32 bits you could tell me without having to use a calculator. It's two to the power of if I've got one bit for sign goes back to the mid term. If I've got 32 bits and they're all positive numbers I can store from zero up to 2 to the power of 32 Right -1 because there's one for zero. Right, - that one for zero. So if I wanted even even range, I've got 32 bits. Right? If I've got eight bits Then it's two to the power of eight right minus one, which is 20 to 2 55. Right? So but if I'm storing positive and negative numbers and I've got eight bets you already gave the answer. What is Hassan is it? Sorry, what's your name again? Yeah. So slowly slowly I'm learning people's names. So um the that you said 127 right? If you've got eight bits and I take one and I want to go positive and negative. I need one of them to represent the sign, right? So I can go. So if I take one of those bits away it's to the power of seven, which is 1 28. Right? Got 1 28 on one side and 1 28 on the other side. But I need one of them for zero. So it's usually 1 27 on one side and and 1 28 on the other side. So ranges between positive um 1 27 2 negative. 1 28. Right? And that would be 256 values as well. Right. So um so here 32 bit into jar can generally uses this first bit to represent positive or negative. Right? And then the 30 the other 31 bits from 0 to 30 Index 0-30 Right? Would represent two to the power of 31 amplitude. Right? But I have I lose one for zero. Okay, so um so what's happening? So why so why do I have? Why do I have negative here? Okay. We know we set this color to red. So what do you think this is negative? Well, if I set it to read, right, which is 255-00. Okay. What should all of these bits in here be for the red pot, the zeros and ones. What's the biggest number. Yeah, they're all ones because the biggest number is to the power of zero plus two to power one plus. So we include all of those values. I am going to go back to the binary thing but not fully today. I'll do a little bit today and then we'll go back a bit deeper after. But 2 55 is all once in binary, right? Zero is all zeros in binary. And then combinations in between are all of the range of values between zero and 2 55. So those bits have to be one in here. Right? But we're getting a negative first of all, we've got a range of values. We've got 65,000. What's going on here? Well, as I said, Red is over here. So, so if they're all ones and these are all Zeros, this intake of value is much bigger than what we think it is. Right. If all of those values were in the blue channel, it would be numbers between zero and 255. But because all of those values are over here, this is actually a much larger number and the fact that this is a negative, it also tells us that these are probably ones over here as well. Right. So the one on that front, I've got a previous slide where we looked at the representation of integers versus floats that bit here is a negative. If it's if it's set and it's it's a positive if it's not set. So that that also tells us that this alpha channel is probably full, which is in a paint color, right? The Alpha channel tells us how transparent it is. So if that was zero would be fully transparent. If it's if it's 100% like value of 2 55 it would be fully opaque. So we've got this big number here. Right? And the question is, how do we get the red and stuff out of it? There's a lot of different ways to get this out. I'll teach you a low level way maybe on friday. Right? I'll just give you, but you know, we don't need to know the low, it's good to understand it. Right? But there are methods that we can actually extract this these values out. All right, hang on, let me get jump back to the so what what we want is these values out of that into um and this is just some more examples here. So red would look like this. Um Gray was in fact an opaque red would have ones here. Um but if you use the version of the image, the p image that just has RGB, we don't care what's in the alpha channel. Everything is treated as opaque. If you use an A R G B, then we care about that Alpha channel. Um and so, you know, this might not be a good representation for an opaque color. Right? So gray for example, typically has the same values in red, green and blue. So a darker gray would have a lower value in red, green and blue and a stronger gray or close to black. Sorry, a darker gray would be closer to black. So it would be closer to zero values. Right? Whiter gray. Like a lighter gray would be closer to white, but you typically see those colors being the same values across the channels. Alright, so um this color here is kind of a mustardy color. Actually has this representation in hex form. So if you if you go to a color picker um if you're using that fig MMA software or whatever you're using Photoshop. Okay, you can actually go and look at what is the hex representation. But what is hex exactly? So, so in the same way that we've got binary and we've got vintages. Right? Hexi decimal is just a convenient because we're working with bytes. Hexi decimal is a convenient way of breaking each one of these bites into 24 digit values? If I've got four digits. Right, that's more than 10 um, digits, isn't it? Right. How many, how many things can I represent with four bits? What's two to the power of 38? So times two 16 Hex hex decimal is a 16 digit number. Decimal is a 10 digit number. We can have the digits range between zero and nine binary is a two digit number? The digits are either zero or 1. Hexi decimal has 16 digits. So what happens when we go past 00-9? That's the 1st 10 digits. And what it does it uses a to f for the next digits. Okay. So it's a number made up of numeric symbols and also some letters. Right? And the 16 of those digits. So that's what hexes. That's why you never see letters more than F. Right? It's only letters A to F and all the digits 0 to 9. And these are the hex to decimal representations used on your routers for example. Right? Like you plug in and you need a Mac address or something from your computer. Anyone seeing this on the back of the router? Right. There's these addresses um they're usually expressed in hex. Okay so if I've got a two digit digit hacks like C. A Basically I've got two digits um the first digit would represent the ones column. So I've got anywhere from zero up to 15 I've got and then I've got um instead of the tens column, I've got the sixteen's column. Okay, so how many sixteens are there in the number? And how many ones are there in the in the number? So C would equate to 12 because after nine we got 10. That's a right then pc So 10, 11, 12. So C is equal to 12 basically. Um and I is equal to 10 and then I can work out what that integer value would be this way I could also do the conversion into binary as well. Um These these are the values that are associated with each of those extra digits, right? So that's what hexi decimal is. So when I go back to here the C and the A. The C represents also the A represents the first four digits right? When I add that together I'd get um two to the power of 38 plus um Eight plus no fours +12 is 10. Okay, that's the A and then the sea would be the other part. Alright. eight Plus 4. Right, is the 12. Okay. So and we said that we've got this alpha channel. Alright, I'm gonna come back to those representation. I just want to explain where they come from. Right? If you take an integer, there is a method in in processing that you can call called hex hex to decimal. Hex or decimal right? You can convert an integer to a hex to decimal. Um So if you wanted to see what the hexi decimal value is for the pixel, you could take its integer and pass it through that method to get the hex right. You could also take a hex to decimal value, pass it to get an integer and assign it as a as a pixel as well. All right. But fortunately there's an easier way there's a method called red, green and blue which you may have used who's used the color method so far because that's the one I've been using where you pass all three colors to the color method or you pass all three colors plus a alpha value to generate um that integer value for for pixel color or for color. Um So you can use these methods red, green and blue to extract um the red part of the pixel or the green part of the pixel or the blue part of the pixel. Okay. And you need to do that in order to work with it in a way that is intuitive when you're working on um color because we think of color in terms of red, green and blue. Okay, so don't use the pixel, extract the red or extract the green, extract the blue, then do something with those. Right, When we're manipulating. So here let's have a look at a quick example where we're going to create um three different versions of an image. Uh And then well I guess we're gonna run out of time so we will continue on Wednesday. Um Alright, so if I create three empty images, um I can set so the first one we've already done, we set to read the second one. I'm setting to a color where I'm just using I as something that's ranging between um zero and the image width which is 300. So I'm actually going up to the maximum value over the maximum value um of 2 55. But after that it's just going to stay as 2 55. Uh And when I is equal to zero, what color have I got? 000 is black. When I is equal to 255, I'm gonna have full red. So every value of iron between I'm gonna slightly be moving from black to red and that's what we see in the bottom left here. So let's uh let's run that. I'm only gonna show image to here.

SPEAKER 1
Is that image too?

SPEAKER 0
Did I change something? Okay. I don't know why I'm getting back the image one. Alright, well um no I'm running something else somewhere, I can't see because it's too big. I'll come back to that. Maybe I'm sitting, I've commented something out. Anyway, I'll come back to this example. Um but basically you can see because I've drawn another one over the top of it here, it's going from black in X to read.

SPEAKER 1
Okay, so I can generate a gradient that way.

SPEAKER 0
And then the third image here um I'm going the opposite. I'm going in the the second channel but I'm using the index for the height right? So as the height gets larger I'm going to be moving from black to green. But what else is happening here is that I'm also in the X direction, changing my alpha channel from transparent all the way through to opaque. So when I print that, when I've created an image that way? And I print that over the top of something else. You're going to start to see the stuff that's underneath. Right? So this one's opaque, this one's opaque, but when I generate this other image over the top, I'm starting to see in the X. Direction, which is I I'm going from transparent to opaque and in the Y direction, I'm going from black to fully green. Okay, so you see there's two different gradients, ones in transparency and one's in um a color on that second image. Okay. Um Alright. And then I place that at the middle so we can also do this between colors. So there and I'll stop with this. But if I um there's methods called loop, which linea they linearly interpret interpolate between two things. Okay, I could I could use the normal function interprets between two single variables, but there's a version of it for color which will take two colors, A starting color and an ending color and it will gradually figure out the color the colors in between for you. Um Anyway, the codes there start to have a play with it. I've got a feeling maybe the next group is going to be coming in so we'll stop the video but have a look at that. Have a look through the rest of the slides And then on Wednesday we'll continue with other manipulations, how else can we get access to the pixels apart from this way and?
